^^

deps.http = 1;
deps.https = 1;
deps.fs = 1;
deps.querystring = 1;
deps.url = 1;
deps.strlen = 1;
deps.append1 = 1;
deps.extend1 = 1;
deps.extend = 1;
deps["form-data"] = 1
$$
requestx = new Req();
function parseRes(res, fn){
	var data = "";
	var isText;
	var ct = res.headers["content-type"];
	if(ct && ct.match("image")){
		isText = false;
		res.setEncoding("binary");
	}else{
		isText = true;
		res.setEncoding("utf8");
	}
	res.on('data', function (chunk) {
		data += chunk;
	});
	res.on('error', function (e) {
		if(fn) fn(e, null, {statusCode: res.statusCode, headers: res.headers});
	});			
	res.on('end',function(){
		if(isText)
			try {
				data = JSON.parse(data);
			}catch(e){
			}
		if(fn) fn(null, data, {statusCode: res.statusCode, headers: res.headers});
	});
}
function Req(defaultOptions, uastr){
	var self = this;
	self.ins = Req;
	if(!uastr) uastr = "disp3/alpha";
	if(!defaultOptions) defaultOptions = {};
	append1(defaultOptions, {
		agent: false,
		rejectUnauthorized: false,
		headers: {}
	});
	append1(defaultOptions.headers, {
		"user-agent": uastr
	})
	function ajax(config, fn){
		if(!config.url.match(":\/")) config.url = "http://" + config.url;
		var urlParsed = url.parse(config.url);
		var options = {};
		extend(options, defaultOptions);
		extend(options, {
			host: urlParsed.hostname,
			path: urlParsed.path,
			method: config.method || "get"
		});
		if(urlParsed.port) options.port = urlParsed.port;		
		extend(options.headers, config.headers);
		var protocol = urlParsed.protocol || "http:";
		var req;
		if(protocol == "http:"){
			req = http.request(options);
		}else if(protocol == "https:"){
			req = https.request(options);
		}else{
			if(fn) fn("wrong protocol " + protocol);
			return;
		}
		if(config.data){
			if(typeof config.data === "string"){
				req.write(config.data);
			}else{
				console.error("data is not string");
				console.error(config.data);
			}
		}
		if(config.stream){
			config.stream.pipe(req);
		}
		req.once("response", function(res){
			if(config.returnStream)
				fn(null, res);
			else
				parseRes(res, fn);
		});

		req.on('error', function(error) {
			if(fn) fn(error);
		});
		req.end();

	}

	self.ajax = ajax;
	["get", "post", "put", "delete"].forEach(function(method){

		self[method + "x"] = function(url, headers, param1, param2){
			var fn, data;
			if(!param2){
				fn = param1;
				data = "";
			}else{
				fn = param2;
				data = param1;
			}
			if(!headers) headers = {};
			var config = {url: url, method: method.toUpperCase(), headers: headers};
			if(data){
				if(typeof data === "string")
					config.data = data;
				else
					config.data = JSON.stringify(data);
				if(!headers["Content-type"]){
					headers["Content-type"] = "application/json;charset=utf-8";
					headers["Content-Length"] = strlen(config.data);
				}
			}
			ajax(config, fn);
		};

		self[method] = function(url, data, fn){
			self[method + "x"](url, {}, data, fn);
		};
		self[method+"Formx"] = function(url, headers, json, fn){
			var data = querystring.stringify(json);
			headers["Content-type"] = "application/x-www-form-urlencoded";
			headers["Content-Length"] = strlen(data);
			self[method + "x"](url, headers, data, fn);
		};
		self[method+"Form"] = function(url, json, fn){
			var data = querystring.stringify(json);
			self[method + "x"](url, {
				"Content-type": "application/x-www-form-urlencoded",
				"Content-Length" : strlen(data)
			}, data, fn);
		};
		self[method+"Json"] = function(url, json, fn){
			var data = JSON.stringify(json);
			self[method + "x"](url, {
				"Content-type": "application/json",
				"Content-Length" : strlen(data)
			}, data, fn);
		};
		self[method + "Cookies"] = function(url, cookies, data, fn){
			var cookiearr = [];
			for(var key in cookies)
				cookiearr.push(key + "=" + cookies[key]);
			self[method + "x"](url, {
				Cookie: cookiearr.join("; ")
			}, data, fn);
		};
		self[method + "FormCookies"] = function(url, cookies, json, fn){
			var cookiearr = [];
			for(var key in cookies)
				cookiearr.push(key + "=" + cookies[key]);
			var data = querystring.stringify(json);
			self[method + "x"](url, {
				"Content-type": "application/x-www-form-urlencoded",
				"Content-Length" : strlen(data),
				Cookie: cookiearr.join("; ")
			}, data, fn);
		};
	});
	self.postMultipartx = function(url, header, json, fn){
//	-------BNDRY123456\r\ncontent-type: text/plain\r\ncontent-disposition: form-data; name="file"; filename="file.txt"\r\n\r\ntest\r\n-------BNDRY123456--		
		var form = new formData();
		for(var key in json){
			var c = json[key];
			if(typeof c == "object" && c.file)
				form.append(key, fs.createReadStream(c.file))
			else
				form.append(key, c)
		}
		header["Content-type"]= "multipart/form-data; boundary="+form._boundary;
		form.getLength(function(err, length){
			header["Content-Length"]=length;
			ajax({
				url: url, 
				method: "post",
				headers: header,
				stream: form
			}, fn);
		});
	}
		
	//modified from git://github.com/jshttp/fresh
	self.fresh = function(reqheaders, resheaders){

		// defaults
		var etagMatches = true;
		var notModified = true;

		// fields
		var modifiedSince = reqheaders['if-modified-since'];
		var noneMatch = reqheaders['if-none-match'];
		var lastModified = resheaders['last-modified'];
		var etag = resheaders['etag'];
		var cc = reqheaders['cache-control'];

		// unconditional request
		if (!modifiedSince && !noneMatch) return false;
		// check for no-cache cache request directive
		if (cc && cc.indexOf('no-cache') !== -1) return false;

		// parse if-none-match
		if (noneMatch) noneMatch = noneMatch.split(/ *, */);

		// if-none-match
		if (noneMatch) etagMatches = ~noneMatch.indexOf(etag) || '*' == noneMatch[0];

		// if-modified-since
		if (modifiedSince) {
			modifiedSince = new Date(modifiedSince);
			lastModified = new Date(lastModified);
			notModified = lastModified <= modifiedSince;
		}

		return !! (etagMatches && notModified);
	}
};
