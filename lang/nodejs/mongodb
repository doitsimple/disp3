^^
deps.mongodb = 1;
deps.ObjectId = 1;
deps.isArray = 1;
deps.eachSync = 1;
deps.project = 1;
var host, port, dbname, authStr, hostStr;
if(!argv.host) host = "127.0.0.1";
if(!argv.port) port = 27017;
if(argv.username && argv.password) authStr = username + ":" + password + "@";
else authStr = "";
hostStr =  "mongodb://" + authStr + host + ":" + port + "/" + (argv.dbname || "main");
$$
new function(){
	var self = this;
	var colDef = ^^=$.stringify(argv.schemas)$$;
	var colArray = Object.keys(colDef);
	var colCache = {};
	var colDataCache = {};
	var conn;
	var formatFuncs = {};
	self.makeFormat = function(config){
		return function(doc){
			if(doc._id) doc._id = ObjectId(doc._id);	
		}
	}
	self.format = function(name, doc){
		if(!formatFuncs[name]) formatFuncs[name] = self.makeFormat(colDef[name]);
		if(isArray(doc)){
			for(var i=0;i<doc.length;i++){
				formatFuncs[name](doc[i]);
			}
		}else{
			formatFuncs[name](doc);
		}
	}
	self.getCol = function(name){
		var col = colCache[name];
		if(!col){
			col = conn.collection(name);
			colCache[name] = col;
		}
		return col;
	}
	self.connect = function(fn){
		mongodb.MongoClient.connect("^^=hostStr$$", function(err, client) {
			if(err) return fn(err);
      conn = client;
			eachSync(colArray, function(e, cb){
				var colConfig = colDef[e];
				if(colConfig.seed){
					self.getCol(e).findOne(function(err, result){
						if(err) return cb(err);
						if(!result){
							self.inserts(e, colConfig.seed, cb);
						}else{
							cb();
						}
					});
				}else{
					cb();
				}
			}, function(err){
			  fn(err, conn);
			});
		})
	}
	self.getCache = function(name, key, fn){
		if(!colDataCache[name]) colDataCache[name] = {};
		var cache = colDataCache[name];
		if(cache[key]) return fn(null, cache[key]);
		self.selectx(name, {$match: {_id: key}, $limit:1}, function(err, result){
			if(err) return fn(err);
			cache[key] = result[0];
			fn(null, result[0]);
		});
	}
	self.aggr = function(name, arr, fn){
		self.getCol(name).aggregate(arr, fn);
	}
	self.selectx = function(name, op, fn){
		var aggrarr = [];
		self.format(name, op.$match);
		if(op.$match) aggrarr.push({$match: op.$match});
    if(op.$sort && Object.keys(op.$sort).length>0)
      aggrarr.push({$sort: op.$sort});
    if(op.$skip)
      aggrarr.push({$skip: parseInt(op.$skip)});
    if(op.$limit)
      aggrarr.push({$limit: parseInt(op.$limit)});
    if(op.$project && Object.keys(op.$project).length>0)
      aggrarr.push({$project: op.$project});
		self.aggr(name, aggrarr, function(err, result){
			if(err) return fn(err);
			if(op.$join){
				if(op.$join.cache){
					var joinConfig = op.$join;
					eachSync(result, function(row, cb){
						self.getCache(joinConfig.schema, row[joinConfig.idField], function(err, result2){
							if(err) return cb(err);
							project(result2, joinConfig.project, row);
							cb();
						});
					}, function(err){
						if(err) return fn(err);
						fn(null, result);
					});
				}else if(op.$join.cacheAll){					
//TODO
				}else{
//TODO
				}
			}else{
				fn(null, result);
			}
		});
	},
	self.insert = function(name, doc, fn){
		self.format(name, doc);
		self.getCol(name).insertOne(doc, function(err, result){
			var id = doc._id;
			delete doc._id;
			if(err) return fn(err);
			fn(null, {insertedId: id});
		});
	}
	self.inserts = function(name, docs, fn){
		self.format(name, docs);
		self.getCol(name).insertMany(docs, fn);
	}
	self.updatex = function(name, where, op, fn){
		self.format(name, where);
		self.format(name, op);
		delete op.$limit;
		self.getCol(name).updateOne(where, op, function(err, result){
      var rtn;
      if(result) rtn = result.result;
      else rtn = {n: 0};
      fn(err, rtn);
    });
	}
	self.sedatex = function(name, where, op, fn){
		self.format(name, where);
		self.format(name, op);
		delete op.$limit;
    self.getCol(name).findAndModify(where, [], op, function(err, doc){
      if(err) return fn(err);
      if(!doc) return fn(null, doc);
      fn(null, doc.value);
    });
	}
	self.drop = function(fn){
		conn.dropDatabase(fn);
	}
}